{
  "version": "2.0.0",
  "name": "email-addresses",
  "description": "An email address parser based on rfc5322",
  "keywords": [
    "email address",
    "parser",
    "rfc5322",
    "5322"
  ],
  "homepage": "https://github.com/FogCreek/email-addresses",
  "author": {
    "name": "Jack Bowman",
    "email": "johnrbowman@gmail.com"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/FogCreek/email-addresses.git"
  },
  "directories": {
    "lib": "./lib"
  },
  "main": "./lib/email-addresses.js",
  "devDependencies": {
    "libxmljs": "~0.8.0",
    "tap": "~0.4.0"
  },
  "scripts": {
    "test": "tap ./test"
  },
  "license": "MIT",
  "readme": "email-addresses.js\n==================\n\nAn RFC 5322 email address parser.\n\nv 2.0.0\n\nWhat?\n-----\nWant to see if something could be an email address? Want to grab the display name or just the address out of a string? Put your regexes down and use this parser!\n\nThis library does not validate email addresses - we can't really do that without sending an email. However, it attempts to parse addresses using the (fairly liberal) grammar specified in RFC 5322. You can use this to check if user input looks like an email address.\n\nWhy use this?\n-------------\nUse this library because you can be sure it really respects the RFC:\n - The functions in the recursive decent parser match up with the productions in the RFC\n - The productions from the RFC are written above each function for easy verification\n - Tests include all of the test cases from the [is_email](https://github.com/dominicsayers/isemail) project, which are extensive\n\nInstallation\n------------\nnpm install email-addresses\n\nExample\n-------\n\n```\n$ node\n> addrs = require(\"email-addresses\")\n{ [Function: parse5322]\n  parseOneAddress: [Function: parseOneAddressSimple],\n  parseAddressList: [Function: parseAddressListSimple] }\n> addrs.parseOneAddress('\"Jack Bowman\" <jack@fogcreek.com>')\n{ parts:\n   { name: [Object],\n     address: [Object],\n     local: [Object],\n     domain: [Object] },\n  name: 'Jack Bowman',\n  address: 'jack@fogcreek.com',\n  local: 'jack',\n  domain: 'fogcreek.com' }\n> addrs.parseAddressList('jack@fogcreek.com, Bob <bob@example.com>')\n[ { parts:\n     { name: null,\n       address: [Object],\n       local: [Object],\n       domain: [Object] },\n    name: null,\n    address: 'jack@fogcreek.com',\n    local: 'jack',\n    domain: 'fogcreek.com' },\n  { parts:\n     { name: [Object],\n       address: [Object],\n       local: [Object],\n       domain: [Object] },\n    name: 'Bob',\n    address: 'bob@example.com',\n    local: 'bob',\n    domain: 'example.com' } ]\n> addrs(\"jack@fogcreek.com\")\n{ ast:\n   { name: 'address-list',\n     tokens: 'jack@fogcreek.com',\n     semantic: 'jack@fogcreek.com',\n     children: [ [Object] ] },\n  addresses:\n   [ { node: [Object],\n       parts: [Object],\n       name: null,\n       address: 'jack@fogcreek.com',\n       local: 'jack',\n       domain: 'fogcreek.com' } ] }\n> addrs(\"bogus\")\nnull\n```\n\nUsage\n-----\nIf you want to simply check whether an address or address list parses, you'll want to call the following functions and check whether the results are null or not: ```parseOneAddress``` for a single address and ```parseAddressList``` for multiple addresses.\n\nIf you want to examine the parsed address, for example to extract a name or address, you have some options. The object returned by ```parseOneAddress``` has four helper values on it: ```name```, ```address```, ```local```, and ```domain```. See the example above to understand is actually returned. (These are equivalent to ```parts.name.semantic```, ```parts.address.semantic```, etc.) These values try to be smart about collapsing whitespace, quotations, and excluding RFC 5322 comments. If you desire, you can also obtain the raw parsed tokens or semantic tokens for those fields. The ```parts``` value is an object referencing nodes in the AST generated. Nodes in the AST have two values of interest here, ```tokens``` and ```semantic```.\n\n```\n> a = addrs.parseOneAddress('Jack  Bowman  <jack@fogcreek.com >')\n> a.parts.name.tokens\n'Jack  Bowman  '\n> a.name\n'Jack Bowman'\n> a.parts.name.semantic\n'Jack Bowman '\n> a.parts.address.tokens\n'jack@fogcreek.com '\n> a.address\n'jack@fogcreek.com'\n> a.parts.address.semantic\n'jack@fogcreek.com'\n```\n\nIf you need to, you can inspect the AST directly. The entire AST is returned when calling the module's function.\n\nReferences\n----------\n - http://tools.ietf.org/html/rfc5322\n - http://code.google.com/p/isemail/\n\nProps\n-----\nMany thanks to [Dominic Sayers](https://github.com/dominicsayers) and his documentation and tests\nfor the [is_email](https://github.com/dominicsayers/isemail) function which helped greatly in writing this parser.\n\nLicense\n-------\nLicensed under the MIT License. See the LICENSE file.\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/FogCreek/email-addresses/issues"
  },
  "_id": "email-addresses@2.0.0",
  "dist": {
    "shasum": "8242d017d78f74f6e5390fe1d15a6bedd7ca0172"
  },
  "_from": "email-addresses@2.0.0",
  "_resolved": "https://registry.npmjs.org/email-addresses/-/email-addresses-2.0.0.tgz"
}
